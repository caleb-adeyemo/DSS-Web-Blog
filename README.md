# Secure Blog System

The aim of this project is to create a secure web-based blog system that mitigates the five most common security vulnerabilities: account enumeration, session hijacking, SQL injection, cross-site scripting, and cross-site request forgery. This project will utilize Node.js, HTML, CSS and vanila Javascript.

## Installation

- Clone the repository to your local machine.
- Create 2 terminals
- Navigate to the directories "Client-html" and "Server" on each respective terminal
- Install Node.js and npm and nodemon on each terminal 
- Install project dependencies with the command `npm init -y` for each terminal.

## Prerequisites

Before you can initialize the database. Using DB managment software like PG admin; upload the "Dss.Sql" file.

Once you have installed pgAdmin or eqiverlent and have the Schema running, you can follow these steps to initialize the database:

DB_USER='' <br>
DB_PASSWORD='' <br>
DB_HOST='' <br>
DB_PORT= <br>
DB_NAME='' <br>
ACCESS_SECRET_TOKEN='' <br>
AUTH_TOKEN_LIFE_SPAN=2 <br>
ACCESS_TOKEN_LIFE_SPAN=2 <br>
REFRESH_TOKEN_LIFE_SPAN=100 <br>

1. Open the `.env` file and fill in the following information. Ensure to change the port (`DB_PORT`) to the port your PostgreSQL server is running on,
2. Fill in the (`DB_USER`), (`DB_PASSWORD`),(`DB_NAME`). For UEA Students, The user and name are tipically your sudent id and the Password would be provided by your module organiser. 
3. The (`DB_HOST`) is tipically dependent on the module and would be hosted by UEA. ask your module organiser for the Host name or you can find it on the pgAmin UI.
4. (`ACCESS_SECRET_TOKEN`) can be generated by creatign a new terminal and runing the command, 'openssl rand -hex 64'. Svae the result into the (`ACCESS_SECRET_TOKEN`) variable.
5. (`ACCESS_TOKEN_LIFE_SPAN`) and (`REFRESH_TOKEN_LIFE_SPAN`) are the time in minutes for the JWT token to expire. This is dependent on your prefrence.

## Usage

- Run the command `npm run dev` in both the Client and sever terminals to start each servers.
- Open a web browser and navigate to `localhost:8000` to view the blog website.

## Security Features

### Authentication and passwords

We implement a robust password policy that mandates all users to create strong passwords comprising a minimum of 8 characters, including at least 1 uppercase letter, 1 lowercase letter, 1 number, and 1 special character.

For password encryption we are using [bcrypt package](https://www.npmjs.com/package/bcrypt) with 10 salt rounds.
The bcrypt library is not susceptible to timing attacks. More infromation regarding this can be found ([Here](https://www.npmjs.com/package/bcrypt#a-note-on-timing-attacks)). 

### 2 Factor Auth.

To further enhance security, our blog implements two-factor authentication (2FA) using the Microsoft Authenticator app. This additional layer of security requires users to generate a one-time password (OTP) through the Microsoft Authenticator app, which can be easily set up by scanning a QR code provided during the login process. This ensures that even if a user’s password is compromised, unauthorized access to their account is prevented without the corresponding OTP from their authenticated device. The setup process is straightforward, and the added security significantly mitigates the risk of unauthorized access and brute force attacks.
 
---

1. ### Account Enumeration Mitigation

To mitigate account enumeration:
- We use generic error messages on failed user authentication which does not disclose whether the username or password
entered is valid or not.

---
2. ### Session Hijacking Mitigation

* #### Cross-Site Request Forgery (CSRF) Prevention
    
    To mitigate the risk of Cross-Site Request Forgery (CSRF) attacks, we have implemented several robust security measures. CSRF attacks exploit the trust a web application has in the user’s browser, allowing malicious actions to be performed on behalf of an authenticated user without their knowledge. Here’s how we protect against these threats:
    * ##### CSRF Tokens:
    Each sensitive operation in our application requires a unique CSRF token. These tokens are securely generated on the server side and embedded within forms or request headers. When a request is made, the server validates the token to ensure it matches the one generated for the current session, thus confirming the legitimacy of the request. This prevents unauthorized actions from being performed by malicious sites.
    * ##### CORS (Cross-Origin Resource Sharing):
    We enforce strict CORS policies to control which origins are allowed to interact with our application. By configuring CORS settings, we ensure that only trusted domains can make cross-origin requests to our server, thereby reducing the attack surface for CSRF attacks.
    ```
    ...
    // CORS configuration
    const allowedOrigins = ['http://localhost:3000', 'http://localhost:8000'];
    app.use(cors({
        origin: function (origin, callback) {
            if (!origin || allowedOrigins.includes(origin)) {
                callback(null, true);
            } else {
                callback(new Error('Not allowed by CORS'));
            }
        },
        credentials: true
    }));
    ...
    ```
    * ##### HTTP Only Cookies:
      We store session IDs and CSRF tokens in HTTP Only cookies. These cookies are inaccessible to client-side JavaScript, which prevents attackers from stealing session data through XSS attacks. By leveraging HTTP Only cookies, we significantly reduce the risk of session hijacking.
---
3. ### SQL Injection Mitigation

    * #### Parameterized queries
      Using precompiled SQL queries with parameter placeholders allows us to send SQL statements and parameters separately. This ensures that parameter values are properly escaped and quoted by the database during execution.

      The use of parameterized queries makes it much more difficult to manipulate SQL queries through input fields, effectively preventing the execution of unauthorized commands and safeguarding against SQL injection attacks.

---
4. ### Cross-Site Scripting (XSS) Mitigation

* #### HTTP Only cookies to store tokens
  Client-side JavaScript can be applied to gain unauthorized access to sessitive information stored in the users cookies; which could have been accessed through XSS attackes. To prevent this, when setting useful information to the hackers like 'csrfTokens' and 'access tokens', 
  the `httpOnly` option is set to `true`.
  
  Additionally, when creating or editing posts, when creating CSRF token for form submission authentication, the
  `httpOnly` option is set to `true` when CSRF token is stored in cookies for the form submission user session.

* #### Sanitizing user-generated input to prevent XSS attacks
  In our application, we take measures to ensure that user-generated content is safely rendered on the page without exposing the site to XSS vulnerabilities. We achieve this by properly encoding user input before storing in the database or displaying it on the client-side. Specifically, we utilize server-side encoding, such as URL encoding, to encode special characters in the user-generated content before sending it to the client. This encoding ensures that any potentially harmful characters, including script tags and JavaScript code, are neutralized and rendered as plain text.

* ##### Client-side rendering of sanitized content
  To further mitigate the risk of XSS attacks, we adopt a client-side rendering approach that ensures the sanitized content is displayed as plain text on the page. Instead of directly injecting user-generated content into the DOM using innerHTML, we utilize methods like textContent or createTextNode to insert the content as plain text. By doing so, we prevent any JavaScript code embedded in the user-generated content from being executed, thus safeguarding against XSS vulnerabilities.
  ```
  ...
  postElement.innerHTML = `
      <div class='post_top'>
        <div class='post-header'>
          <img class='userDp' src='../../Assets/Images/emoji.jpg' alt='User DP' />
          <p class='username'>${post.c_name} <span class='userTag'>${post.c_tag}</span></p>
        </div>
        <p class='post_message'></p> <!-- Create an empty paragraph element -->
      </div>
      <div class='media'>
        <img src='../../Assets/Images/post.jpg' alt='post content media' />
      </div>
    `;

    // Set the decoded message content as plain text
    const postMessageElement = postElement.querySelector('.post_message');
    postMessageElement.textContent = decodeURIComponent(post.post_msg);
  ...
  ```


  Our approach not only protects the application from XSS attacks but also ensures usability by allowing users to include symbols and special characters in their input. By properly sanitizing and rendering user-generated content, we maintain a balance between security and usability, providing a safe browsing experience for all users.

---

